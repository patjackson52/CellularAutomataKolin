package com.jackson.celluar_generator


class CellularGenerator(val ruleSet: Int, val width: Int) {
/*
    val rulesMap: Map<BitSet, Boolean>
    val rulesArray = arrayOf(
            bitSetOf(true, true, true),
            bitSetOf(true, true, false),
            bitSetOf(true, false, true),
            bitSetOf(true, false, false),
            bitSetOf(false, true, true),
            bitSetOf(false, true, false),
            bitSetOf(false, false, true),
            bitSetOf(false, false, false)
    )

    init {
        val rule = BitSet.valueOf(ruleSet)
        val booleanArray = BooleanArray(1)
        booleanArrayOf()
        rulesMap = (0..7).associate { rulesArray[it] to }
    }

    fun start() {
        val firstGeneration = BitSet(width)
        firstGeneration.set(width / 2)
    }

    interface Callbacks {
        fun onNextGeneration()
    }

    private fun generateNext(current: BitSet) {
        val nextGen = BitSet(width)
        for (i in 1..width) {
            val neighborHood = current.get(i - 1, i + 1)
        }
    }

    private fun findNextGen(neighborHood: BitSet) {

        bitSetOf(true, false, true)

    }

    fun bitSetOf(vararg bits: Boolean): BitSet {
        val bitSet = BitSet(bits.size)
        bits.forEachIndexed { index, b -> bitSet.set(index, b) }
        return bitSet
    }
*/
}

